{% extends "base.html" %}

{% block title %}Photo Mosaic - Celebration Display{% endblock %}

{% block content %}
<div class="photo-mosaic-container">
    <div class="container-fluid py-3">
        <!-- Add quick navigation -->
        <div class="text-center mb-3">
            <a href="{{ url_for('index') }}" class="btn btn-primary me-2">üéä Add Another Entry</a>
            <a href="{{ url_for('admin') }}" class="btn btn-outline-secondary me-2">‚öôÔ∏è Admin</a>
            <button onclick="testAnimation()" class="btn btn-outline-warning btn-sm">üß™ Test Animation</button>
        </div>
        
        <div class="photo-mosaic-wrapper" id="photoMosaicWrapper">
            <div id="photoMosaicGrid" class="photo-mosaic-grid">
                {% if entries %}
                    {% for entry in entries %}
                    <div class="photo-tile" data-entry-id="{{ loop.index }}" 
                         data-bs-toggle="tooltip" data-bs-title="{{ entry.name }}: {{ entry.message }}">
                        <div class="tile-bg-symbol">
                            <img src="{{ url_for('static', filename='symbols/' + entry.symbol) }}" 
                                 alt="Symbol" class="symbol-image">
                        </div>
                        <div class="tile-content">
                            <div class="tile-name">{{ entry.name[:15] }}{% if entry.name|length > 15 %}...{% endif %}</div>
                            <div class="tile-message">{{ entry.message[:35] }}{% if entry.message|length > 35 %}...{% endif %}</div>
                        </div>
                    </div>
                    {% endfor %}
                {% else %}
                <div class="empty-mosaic text-center py-5">
                    <div class="display-1 mb-3 text-white-50">üéä</div>
                    <h3 class="text-white">Building photo mosaic...</h3>
                    <p class="text-white-50">Waiting for celebration tiles to appear</p>
                    <p class="text-white-50 small">Updates automatically when new entries arrive</p>
                </div>
                {% endif %}
            </div>
            <div id="logoOverlay" class="logo-overlay"></div>
        </div>
    </div>
</div>

<script>
// Photo Mosaic Variables
let tileSize = 50; // Larger tiles for better text readability
let mosaicWidth = 800;  // Fixed mosaic width
let mosaicHeight = 600; // Fixed mosaic height
let gridCols = 0;
let gridRows = 0;
let refreshInterval;
let totalEntries = 0;
let lastEntryCount = 0;
let currentLogoUrl = '';

// Initialize photo mosaic
document.addEventListener('DOMContentLoaded', function() {
    initializePhotoMosaic();
    initializeTooltips();
});

function initializeTooltips() {
    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
    [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));
}

function initializePhotoMosaic() {
    setupMosaicGrid();
    loadLogoOverlay();
    
    // Check for new entries every 3 seconds (but only refresh if count changed)
    refreshInterval = setInterval(checkForNewEntries, 3000);
}

function loadLogoOverlay() {
    // Fetch current admin settings to get the latest logo
    fetch('/api/admin-settings')
        .then(response => response.json())
        .then(settings => {
            const logoUrl = `/static/${settings.logo_filename}?t=${Date.now()}`;
            updateLogoOverlay(logoUrl);
        })
        .catch(error => {
            console.error('Error fetching admin settings:', error);
            // Fallback to template value
            const logoUrl = '{{ url_for("static", filename=logo_filename) }}?t=' + Date.now();
            updateLogoOverlay(logoUrl);
        });
}

function updateLogoOverlay(logoUrl) {
    const logoOverlay = document.getElementById('logoOverlay');
    if (logoOverlay && logoUrl !== currentLogoUrl) {
        currentLogoUrl = logoUrl;
        logoOverlay.style.backgroundImage = `url('${logoUrl}')`;
        console.log('Logo overlay updated:', logoUrl);
    }
}

async function calculateOptimalGrid(numEntries, settings) {
    return new Promise((resolve) => {
        // Use requestAnimationFrame for smooth non-blocking calculation
        requestAnimationFrame(() => {
            if (settings && settings.grid_mode === 'manual') {
                resolve({ 
                    cols: settings.grid_cols || 12, 
                    rows: settings.grid_rows || 10 
                });
                return;
            }
            
            if (numEntries === 0) {
                resolve({ cols: 1, rows: 1 });
                return;
            }
            
            // Calculate grid dimensions based on number of entries
            // Try to maintain logo aspect ratio (4:3)
            const aspectRatio = mosaicWidth / mosaicHeight;
            
            // Find the best grid size for the number of entries
            let bestCols = 1, bestRows = 1;
            let minWaste = Infinity;
            
            const maxCols = Math.ceil(Math.sqrt(numEntries * aspectRatio)) + 5;
            
            // Break calculation into chunks to avoid blocking
            let currentCol = 1;
            const calculateChunk = () => {
                const endCol = Math.min(currentCol + 5, maxCols + 1);
                
                for (let cols = currentCol; cols < endCol; cols++) {
                    const rows = Math.ceil(numEntries / cols);
                    const totalCells = cols * rows;
                    const waste = totalCells - numEntries;
                    const currentRatio = cols / rows;
                    const ratioError = Math.abs(currentRatio - aspectRatio);
                    
                    // Prefer grids closer to target aspect ratio with less waste
                    const score = waste + (ratioError * 10);
                    
                    if (score < minWaste) {
                        minWaste = score;
                        bestCols = cols;
                        bestRows = rows;
                    }
                }
                
                currentCol = endCol;
                if (currentCol <= maxCols) {
                    requestAnimationFrame(calculateChunk);
                } else {
                    resolve({ cols: bestCols, rows: bestRows });
                }
            };
            
            calculateChunk();
        });
    });
}

// Removed analyzeBackgroundImage - no longer needed for overlay approach

function setupMosaicGrid() {
    const wrapper = document.getElementById('photoMosaicWrapper');
    wrapper.style.position = 'relative';
    wrapper.style.width = '100%';
    wrapper.style.maxWidth = '1200px';
    wrapper.style.margin = '0 auto';
}

function setupDefaultGrid() {
    // Use fixed resolution even when background image fails
    const grid = calculateOptimalGrid(totalEntries, null);
    gridCols = grid.cols;
    gridRows = grid.rows;
    tileSize = Math.min(mosaicWidth / gridCols, mosaicHeight / gridRows);
    positionTiles();
}

// Removed getPixelData - no longer needed for overlay approach

async function positionTiles(settings = null) {
    const tiles = document.querySelectorAll('.photo-tile');
    const grid = document.getElementById('photoMosaicGrid');
    
    if (!grid) return;
    
    // Calculate optimal grid based on settings and number of entries
    totalEntries = tiles.length;
    
    // Run grid calculation asynchronously
    const optimalGrid = await calculateOptimalGrid(totalEntries, settings);
    gridCols = optimalGrid.cols;
    gridRows = optimalGrid.rows;
    
    // Calculate tile size to fit fixed mosaic resolution
    tileSize = Math.min(mosaicWidth / gridCols, mosaicHeight / gridRows);
    
    // Adjust actual mosaic size to accommodate the grid perfectly
    const actualWidth = gridCols * tileSize;
    const actualHeight = gridRows * tileSize;
    
    // Apply grid styles immediately
    requestAnimationFrame(() => {
        grid.style.position = 'relative';
        grid.style.width = actualWidth + 'px';
        grid.style.height = actualHeight + 'px';
        grid.style.margin = '0 auto';
        grid.style.border = '2px solid rgba(255,255,255,0.3)';
        grid.style.imageRendering = 'pixelated';
        grid.style.imageRendering = '-moz-crisp-edges';
        grid.style.imageRendering = 'crisp-edges';
    });
    
    // Create positions and get entry positions in parallel
    const [positions, entryPositions] = await Promise.all([
        createGridPositions(gridRows, gridCols, tileSize),
        getEntryPositions(tiles.length, gridRows * gridCols)
    ]);
    
    // Position tiles in batches for smooth animation
    await positionTilesInBatches(tiles, positions, entryPositions);
    
    // Fill remaining positions with empty tiles
    await fillEmptyPositions(grid, positions, entryPositions, tiles.length);
}

async function createGridPositions(gridRows, gridCols, tileSize) {
    return new Promise((resolve) => {
        requestAnimationFrame(() => {
            const positions = [];
            for (let row = 0; row < gridRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    const x = col * tileSize;
                    const y = row * tileSize;
                    
                    positions.push({ 
                        x, y, 
                        row, col,
                        index: positions.length
                    });
                }
            }
            resolve(positions);
        });
    });
}

async function positionTilesInBatches(tiles, positions, entryPositions) {
    const batchSize = 5;
    const tilesArray = Array.from(tiles);
    
    for (let i = 0; i < tilesArray.length; i += batchSize) {
        await new Promise((resolve) => {
            requestAnimationFrame(() => {
                const batch = tilesArray.slice(i, i + batchSize);
                
                batch.forEach((tile, batchIndex) => {
                    const index = i + batchIndex;
                    const entryId = tile.getAttribute('data-entry-id');
                    const positionIndex = entryPositions[entryId] || entryPositions[index] || 0;
                    
                    if (positionIndex < positions.length) {
                        const pos = positions[positionIndex];
                        tile.style.position = 'absolute';
                        tile.style.left = pos.x + 'px';
                        tile.style.top = pos.y + 'px';
                        tile.style.width = tileSize + 'px';
                        tile.style.height = tileSize + 'px';
                        
                        // Simple tile styling without color analysis
                        tile.style.transform = 'translateZ(0)'; // Force hardware acceleration
                    }
                });
                
                resolve();
            });
        });
    }
}

async function fillEmptyPositions(grid, positions, entryPositions, tileCount) {
    const totalPositions = positions.length;
    if (totalPositions <= tileCount) return;
    
    return new Promise((resolve) => {
        requestAnimationFrame(() => {
            // Find unused positions
            const usedPositionIndices = new Set(Object.values(entryPositions).slice(0, tileCount));
            
            for (let i = 0; i < positions.length; i++) {
                if (!usedPositionIndices.has(i)) {
                    const pos = positions[i];
                    const emptyTile = document.createElement('div');
                    emptyTile.className = 'photo-tile empty-tile';
                    emptyTile.style.position = 'absolute';
                    emptyTile.style.left = pos.x + 'px';
                    emptyTile.style.top = pos.y + 'px';
                    emptyTile.style.width = tileSize + 'px';
                    emptyTile.style.height = tileSize + 'px';
                    
                    // Simple empty tile without color analysis
                    emptyTile.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                    emptyTile.style.border = '1px solid rgba(255, 255, 255, 0.2)';
                    
                    grid.appendChild(emptyTile);
                }
            }
            
            resolve();
        });
    });
}

function checkForNewEntries() {
    // Check entry count first to avoid unnecessary refreshes
    fetch('/api/entries')
        .then(response => response.json())
        .then(entries => {
            const currentCount = entries.length;
            
            // Only refresh if entry count changed or it's the first load
            if (currentCount !== lastEntryCount || lastEntryCount === 0) {
                const wasNewEntry = lastEntryCount > 0 && currentCount > lastEntryCount;
                lastEntryCount = currentCount;
                refreshMosaic(entries, wasNewEntry);
            }
        })
        .catch(error => {
            console.error('Error checking entries:', error);
        });
}

function refreshMosaic(entries = null, animateNew = false) {
    // If entries not provided, fetch them along with settings
    if (entries === null) {
        Promise.all([
            fetch('/api/entries').then(response => response.json()),
            fetch('/api/admin-settings').then(response => response.json())
        ])
        .then(([entries, settings]) => {
            // Check if logo has changed
            const newLogoUrl = `/static/${settings.logo_filename}?t=${Date.now()}`;
            
            if (newLogoUrl !== currentLogoUrl) {
                // Logo changed, update overlay
                updateLogoOverlay(newLogoUrl);
            }
            
            updatePhotoMosaicGrid(entries, settings, animateNew);
        })
        .catch(error => {
            console.error('Error refreshing mosaic:', error);
        });
    } else {
        // Use provided entries and fetch only settings
        fetch('/api/admin-settings')
            .then(response => response.json())
            .then(settings => {
                // Check if logo has changed
                const newLogoUrl = `/static/${settings.logo_filename}?t=${Date.now()}`;
                
                if (newLogoUrl !== currentLogoUrl) {
                    // Logo changed, update overlay
                    updateLogoOverlay(newLogoUrl);
                }
                
                updatePhotoMosaicGrid(entries, settings, animateNew);
            })
            .catch(error => {
                console.error('Error fetching settings:', error);
                // Fallback to just entries without settings
                updatePhotoMosaicGrid(entries, null, animateNew);
            });
    }
}

async function getEntryPositions(entryCount, totalPositions) {
    return new Promise((resolve) => {
        requestAnimationFrame(() => {
            // Get existing position assignments from localStorage
            let savedPositions = {};
            try {
                savedPositions = JSON.parse(localStorage.getItem('entryPositions') || '{}');
            } catch (e) {
                savedPositions = {};
            }
            
            // Create shuffled position pool if it doesn't exist
            let availablePositions = [];
            try {
                availablePositions = JSON.parse(localStorage.getItem('availablePositions') || '[]');
            } catch (e) {
                availablePositions = [];
            }
            
            // Initialize position pool if empty or wrong size
            if (availablePositions.length === 0 || availablePositions.length !== totalPositions) {
                availablePositions = Array.from({length: totalPositions}, (_, i) => i);
                // Shuffle the available positions
                for (let i = availablePositions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [availablePositions[i], availablePositions[j]] = [availablePositions[j], availablePositions[i]];
                }
                localStorage.setItem('availablePositions', JSON.stringify(availablePositions));
            }
            
            // Assign positions to entries that don't have them
            const currentEntryIds = Array.from(document.querySelectorAll('.photo-tile')).map(tile => 
                tile.getAttribute('data-entry-id') || String(Array.from(tile.parentNode.children).indexOf(tile))
            );
            
            let nextPositionIndex = 0;
            currentEntryIds.forEach((entryId, index) => {
                if (!(entryId in savedPositions)) {
                    // Find next available position
                    while (nextPositionIndex < availablePositions.length && 
                           Object.values(savedPositions).includes(availablePositions[nextPositionIndex])) {
                        nextPositionIndex++;
                    }
                    
                    if (nextPositionIndex < availablePositions.length) {
                        savedPositions[entryId] = availablePositions[nextPositionIndex];
                        nextPositionIndex++;
                    } else {
                        // Fallback to index if we run out of positions
                        savedPositions[entryId] = index % totalPositions;
                    }
                }
            });
            
            // Save updated positions
            localStorage.setItem('entryPositions', JSON.stringify(savedPositions));
            
            resolve(savedPositions);
        });
    });
}

function updatePhotoMosaicGrid(entries, settings = null, animateNewest = false) {
    const grid = document.getElementById('photoMosaicGrid');
    if (!grid) return;
    
    // Store previous entry count to detect new entries
    const previousTiles = grid.querySelectorAll('.photo-tile');
    const hadEntries = previousTiles.length > 0;
    const isNewEntry = hadEntries && entries.length > previousTiles.length;
    
    // Clear existing tiles (keep the grid structure)
    const existingTiles = grid.querySelectorAll('.photo-tile, .empty-tile');
    existingTiles.forEach(tile => tile.remove());
    
    if (entries.length === 0 && (!settings || settings.grid_mode !== 'manual')) {
        // Only reload if we're in auto mode and have no entries
        const emptyMessage = document.createElement('div');
        emptyMessage.className = 'empty-mosaic text-center py-5';
        emptyMessage.innerHTML = `
            <div class="display-1 mb-3 text-white-50">üéä</div>
            <h3 class="text-white">Building photo mosaic...</h3>
            <p class="text-white-50">Waiting for celebration tiles to appear</p>
            <p class="text-white-50 small">Updates automatically when new entries arrive</p>
        `;
        grid.appendChild(emptyMessage);
        return;
    }
    
    entries.forEach((entry, index) => {
        const tile = document.createElement('div');
        tile.className = 'photo-tile';
        // Use entry ID if available, otherwise fall back to index
        const entryId = entry.id || String(index);
        tile.setAttribute('data-entry-id', entryId);
        tile.setAttribute('data-bs-toggle', 'tooltip');
        tile.setAttribute('data-bs-title', `${escapeHtml(entry.name)}: ${escapeHtml(entry.message)}`);
        
        const name = entry.name.length > 15 ? entry.name.substring(0, 15) + '...' : entry.name;
        const message = entry.message.length > 35 ? entry.message.substring(0, 35) + '...' : entry.message;
        
        tile.innerHTML = `
            <div class="tile-bg-symbol">
                <img src="/static/symbols/${entry.symbol}" alt="Symbol" class="symbol-image">
            </div>
            <div class="tile-content">
                <div class="tile-name">${escapeHtml(name)}</div>
                <div class="tile-message">${escapeHtml(message)}</div>
            </div>
        `;
        
        // Mark newest tile for animation if it's a new entry
        if ((isNewEntry && index === entries.length - 1) || (animateNewest && index === entries.length - 1)) {
            console.log('Marking tile as newest for animation:', index, entries.length - 1);
            tile.classList.add('newest-tile');
        }
        
        grid.appendChild(tile);
    });
    
    // Reposition tiles after update using async positioning
    setTimeout(async () => {
        await positionTiles(settings);
        initializeTooltips();
        
        // Trigger animation for newest tile
        const newestTile = grid.querySelector('.newest-tile');
        console.log('Looking for newest tile:', newestTile, 'Should animate:', (isNewEntry || animateNewest));
        if (newestTile && (isNewEntry || animateNewest)) {
            console.log('Triggering animation for newest tile');
            animateNewTile(newestTile);
        }
    }, 50);
    
    // Update counter
    const badge = document.querySelector('.badge.bg-info');
    if (badge) {
        const totalTiles = settings && settings.grid_mode === 'manual' 
            ? (settings.grid_rows || 10) * (settings.grid_cols || 12)
            : entries.length;
        badge.textContent = `${entries.length}/${totalTiles} tiles`;
    }
}

function animateNewTile(tile) {
    console.log('Starting animation for tile:', tile);
    
    // Store the final position
    const finalLeft = tile.style.left;
    const finalTop = tile.style.top;
    
    console.log('Final position:', finalLeft, finalTop);
    
    // Set final position as CSS custom properties for animation
    tile.style.setProperty('--final-left', finalLeft);
    tile.style.setProperty('--final-top', finalTop);
    
    // Add animation class and start from center
    tile.classList.add('tile-falling');
    
    console.log('Added tile-falling class');
    
    // After animation completes, clean up
    setTimeout(() => {
        console.log('Animation complete, cleaning up');
        tile.classList.remove('tile-falling', 'newest-tile');
        tile.style.left = finalLeft;
        tile.style.top = finalTop;
    }, 1500);
}

function triggerNewestTileAnimation() {
    // Find all tiles and animate the last one (newest)
    const tiles = document.querySelectorAll('.photo-tile');
    if (tiles.length > 0) {
        const newestTile = tiles[tiles.length - 1];
        newestTile.classList.add('newest-tile');
        animateNewTile(newestTile);
    }
}

function testAnimation() {
    console.log('Test animation triggered');
    const tiles = document.querySelectorAll('.photo-tile');
    if (tiles.length > 0) {
        // Pick a random tile to animate
        const randomTile = tiles[Math.floor(Math.random() * tiles.length)];
        console.log('Animating random tile:', randomTile);
        animateNewTile(randomTile);
    } else {
        console.log('No tiles found to animate');
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Handle window resize
window.addEventListener('resize', function() {
    setTimeout(() => {
        if (backgroundImage && backgroundImage.complete) {
            analyzeBackgroundImage();
            positionTiles();
        }
    }, 250);
});

// Clean up on page unload
window.addEventListener('beforeunload', () => {
    if (refreshInterval) {
        clearInterval(refreshInterval);
    }
});
</script>
{% endblock %}
