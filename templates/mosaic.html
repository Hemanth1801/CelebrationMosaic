{% extends "base.html" %}

{% block title %}Photo Mosaic - Celebration Display{% endblock %}

{% block content %}
<div class="photo-mosaic-container">
    <div class="container-fluid py-3">
        <div class="text-center mb-3">
            <h1 class="display-5 text-white mb-2">ðŸŽ‰ Photo Mosaic</h1>
            <p class="text-white-50">Small celebration tiles recreating the big picture</p>
            <div class="mb-3">
                <button class="btn btn-outline-light btn-sm" onclick="refreshMosaic()">ðŸ”„ Refresh Now</button>
                <span class="badge bg-success ms-2">Auto-refreshing every 10 seconds</span>
                <span class="badge bg-info ms-1">{{ entries|length }} tiles</span>
            </div>
        </div>

        <div class="photo-mosaic-wrapper" id="photoMosaicWrapper">
            <canvas id="analysisCanvas" style="display: none;"></canvas>
            <div id="photoMosaicGrid" class="photo-mosaic-grid">
                {% if entries %}
                    {% for entry in entries %}
                    <div class="photo-tile" data-entry-id="{{ loop.index }}" 
                         data-bs-toggle="tooltip" data-bs-title="{{ entry.name }}: {{ entry.message }}">
                        <div class="tile-symbol">{{ entry.symbol }}</div>
                        <div class="tile-name">{{ entry.name[:8] }}{% if entry.name|length > 8 %}...{% endif %}</div>
                        <div class="tile-message">{{ entry.message[:20] }}{% if entry.message|length > 20 %}...{% endif %}</div>
                    </div>
                    {% endfor %}
                {% else %}
                <div class="empty-mosaic text-center py-5">
                    <div class="display-1 mb-3 text-white-50">ðŸŽŠ</div>
                    <h3 class="text-white">Building photo mosaic...</h3>
                    <p class="text-white-50">Waiting for celebration tiles to appear</p>
                    <p class="text-white-50 small">Auto-refreshing every 10 seconds</p>
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<script>
// Photo Mosaic Variables
let backgroundImage = null;
let backgroundImageData = null;
let tileSize = 20;
let mosaicWidth = 0;
let mosaicHeight = 0;
let gridCols = 0;
let gridRows = 0;
let refreshInterval;

// Initialize photo mosaic
document.addEventListener('DOMContentLoaded', function() {
    initializePhotoMosaic();
    initializeTooltips();
});

function initializeTooltips() {
    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
    [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));
}

function initializePhotoMosaic() {
    const logoUrl = '{{ url_for("static", filename=logo_filename) }}';
    loadBackgroundImage(logoUrl);
    setupMosaicGrid();
    
    // Start auto-refresh
    refreshInterval = setInterval(refreshMosaic, 10000);
}

function loadBackgroundImage(url) {
    backgroundImage = new Image();
    backgroundImage.crossOrigin = 'anonymous';
    backgroundImage.onload = function() {
        analyzeBackgroundImage();
        positionTiles();
    };
    backgroundImage.onerror = function() {
        console.log('Could not load background image, using default positioning');
        setupDefaultGrid();
    };
    backgroundImage.src = url;
}

function analyzeBackgroundImage() {
    const canvas = document.getElementById('analysisCanvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size based on viewport - higher resolution
    const wrapper = document.getElementById('photoMosaicWrapper');
    mosaicWidth = Math.min(wrapper.clientWidth, 1600);
    mosaicHeight = Math.min(mosaicWidth * 0.75, 1200);
    
    // Calculate grid dimensions first
    gridCols = Math.floor(mosaicWidth / tileSize);
    gridRows = Math.floor(mosaicHeight / tileSize);
    
    // Adjust mosaic size to fit exact grid
    mosaicWidth = gridCols * tileSize;
    mosaicHeight = gridRows * tileSize;
    
    canvas.width = mosaicWidth;
    canvas.height = mosaicHeight;
    
    // Draw background image for analysis only
    ctx.drawImage(backgroundImage, 0, 0, mosaicWidth, mosaicHeight);
    
    // Get image data for pixel analysis
    backgroundImageData = ctx.getImageData(0, 0, mosaicWidth, mosaicHeight);
}

function setupMosaicGrid() {
    const wrapper = document.getElementById('photoMosaicWrapper');
    wrapper.style.position = 'relative';
    wrapper.style.width = '100%';
    wrapper.style.maxWidth = '1200px';
    wrapper.style.margin = '0 auto';
}

function setupDefaultGrid() {
    // Fallback when background image fails to load
    const wrapper = document.getElementById('photoMosaicWrapper');
    mosaicWidth = Math.min(wrapper.clientWidth, 1600);
    mosaicHeight = Math.min(mosaicWidth * 0.75, 1200);
    gridCols = Math.floor(mosaicWidth / tileSize);
    gridRows = Math.floor(mosaicHeight / tileSize);
    positionTiles();
}

function getPixelData(x, y) {
    if (!backgroundImageData) return { r: 128, g: 128, b: 128, brightness: 128 };
    
    const index = (y * backgroundImageData.width + x) * 4;
    const r = backgroundImageData.data[index];
    const g = backgroundImageData.data[index + 1];
    const b = backgroundImageData.data[index + 2];
    
    // Calculate brightness using standard formula
    const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
    
    return { r, g, b, brightness };
}

function positionTiles() {
    const tiles = document.querySelectorAll('.photo-tile');
    const grid = document.getElementById('photoMosaicGrid');
    
    if (!grid || tiles.length === 0) return;
    
    grid.style.position = 'relative';
    grid.style.width = mosaicWidth + 'px';
    grid.style.height = mosaicHeight + 'px';
    grid.style.margin = '0 auto';
    grid.style.border = '2px solid rgba(255,255,255,0.3)';
    
    // Create grid positions that match the background image
    const positions = [];
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            const x = col * tileSize;
            const y = row * tileSize;
            const centerX = x + tileSize / 2;
            const centerY = y + tileSize / 2;
            const pixelData = getPixelData(centerX, centerY);
            
            positions.push({ 
                x, y, 
                color: pixelData,
                row, col,
                used: false 
            });
        }
    }
    
    // Fill grid positions sequentially to maintain image structure
    tiles.forEach((tile, index) => {
        if (index < positions.length) {
            const pos = positions[index];
            tile.style.position = 'absolute';
            tile.style.left = pos.x + 'px';
            tile.style.top = pos.y + 'px';
            tile.style.width = tileSize + 'px';
            tile.style.height = tileSize + 'px';
            
            // Apply color tinting to match background image
            const { r, g, b, brightness } = pos.color;
            const alpha = brightness < 100 ? 0.7 : brightness > 200 ? 0.95 : 0.85;
            
            // Create color overlay effect
            tile.style.backgroundColor = `rgba(${r}, ${g}, ${b}, 0.3)`;
            tile.style.borderColor = `rgba(${r}, ${g}, ${b}, 0.5)`;
            
            // Adjust text color for contrast
            if (brightness < 128) {
                tile.style.color = '#fff';
                tile.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)';
            } else {
                tile.style.color = '#000';
                tile.style.textShadow = '1px 1px 2px rgba(255,255,255,0.8)';
            }
        }
    });
    
    // Fill empty positions with placeholder tiles if we have fewer submissions
    const totalPositions = gridRows * gridCols;
    if (tiles.length < totalPositions) {
        for (let i = tiles.length; i < totalPositions; i++) {
            const pos = positions[i];
            const emptyTile = document.createElement('div');
            emptyTile.className = 'photo-tile empty-tile';
            emptyTile.style.position = 'absolute';
            emptyTile.style.left = pos.x + 'px';
            emptyTile.style.top = pos.y + 'px';
            emptyTile.style.width = tileSize + 'px';
            emptyTile.style.height = tileSize + 'px';
            
            const { r, g, b } = pos.color;
            emptyTile.style.backgroundColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
            emptyTile.style.border = `1px solid rgba(${r}, ${g}, ${b}, 0.8)`;
            
            grid.appendChild(emptyTile);
        }
    }
}

function refreshMosaic() {
    fetch('/api/entries')
        .then(response => response.json())
        .then(data => {
            updatePhotoMosaicGrid(data);
        })
        .catch(error => {
            console.error('Error fetching entries:', error);
        });
}

function updatePhotoMosaicGrid(entries) {
    const grid = document.getElementById('photoMosaicGrid');
    if (!grid) return;
    
    if (entries.length === 0) {
        window.location.reload();
        return;
    }
    
    // Clear existing tiles (keep the grid structure)
    const existingTiles = grid.querySelectorAll('.photo-tile, .empty-tile');
    existingTiles.forEach(tile => tile.remove());
    
    entries.forEach((entry, index) => {
        const tile = document.createElement('div');
        tile.className = 'photo-tile';
        tile.setAttribute('data-entry-id', index + 1);
        tile.setAttribute('data-bs-toggle', 'tooltip');
        tile.setAttribute('data-bs-title', `${escapeHtml(entry.name)}: ${escapeHtml(entry.message)}`);
        
        const name = entry.name.length > 6 ? entry.name.substring(0, 6) + '...' : entry.name;
        const message = entry.message.length > 15 ? entry.message.substring(0, 15) + '...' : entry.message;
        
        tile.innerHTML = `
            <div class="tile-symbol">${entry.symbol}</div>
            <div class="tile-name">${escapeHtml(name)}</div>
            <div class="tile-message">${escapeHtml(message)}</div>
        `;
        
        grid.appendChild(tile);
    });
    
    // Reposition tiles after update
    setTimeout(() => {
        positionTiles();
        initializeTooltips();
    }, 100);
    
    // Update counter
    const badge = document.querySelector('.badge.bg-info');
    if (badge) {
        badge.textContent = `${entries.length} tiles`;
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Handle window resize
window.addEventListener('resize', function() {
    setTimeout(() => {
        if (backgroundImage && backgroundImage.complete) {
            analyzeBackgroundImage();
            positionTiles();
        }
    }, 250);
});

// Clean up on page unload
window.addEventListener('beforeunload', () => {
    if (refreshInterval) {
        clearInterval(refreshInterval);
    }
});
</script>
{% endblock %}
