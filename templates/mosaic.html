{% extends "base.html" %}

{% block title %}Photo Mosaic - Celebration Display{% endblock %}

{% block content %}
<div class="photo-mosaic-container">
    <div class="container-fluid py-3">
        <div class="photo-mosaic-wrapper" id="photoMosaicWrapper">
            <div id="photoMosaicGrid" class="photo-mosaic-grid">
                {% if entries %}
                    {% for entry in entries %}
                    <div class="photo-tile" data-entry-id="{{ loop.index }}" 
                         data-bs-toggle="tooltip" data-bs-title="{{ entry.name }}: {{ entry.message }}">
                        <div class="tile-bg-symbol">
                            <img src="{{ url_for('static', filename='symbols/' + entry.symbol) }}" 
                                 alt="Symbol" class="symbol-image">
                        </div>
                        <div class="tile-content">
                            <div class="tile-name">{{ entry.name[:15] }}{% if entry.name|length > 15 %}...{% endif %}</div>
                            <div class="tile-message">{{ entry.message[:35] }}{% if entry.message|length > 35 %}...{% endif %}</div>
                        </div>
                    </div>
                    {% endfor %}
                {% else %}
                <div class="empty-mosaic text-center py-5">
                    <div class="display-1 mb-3 text-white-50">ðŸŽŠ</div>
                    <h3 class="text-white">Building photo mosaic...</h3>
                    <p class="text-white-50">Waiting for celebration tiles to appear</p>
                    <p class="text-white-50 small">Updates automatically when new entries arrive</p>
                </div>
                {% endif %}
            </div>
            <div id="logoOverlay" class="logo-overlay"></div>
        </div>
    </div>
</div>

<script>
// Photo Mosaic Variables
let tileSize = 50; // Larger tiles for better text readability
let mosaicWidth = 800;  // Fixed mosaic width
let mosaicHeight = 600; // Fixed mosaic height
let gridCols = 0;
let gridRows = 0;
let refreshInterval;
let totalEntries = 0;
let lastEntryCount = 0;
let currentLogoUrl = '';

// Initialize photo mosaic
document.addEventListener('DOMContentLoaded', function() {
    initializePhotoMosaic();
    initializeTooltips();
});

function initializeTooltips() {
    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
    [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));
}

function initializePhotoMosaic() {
    setupMosaicGrid();
    loadLogoOverlay();
    
    // Check for new entries every 3 seconds (but only refresh if count changed)
    refreshInterval = setInterval(checkForNewEntries, 3000);
}

function loadLogoOverlay() {
    // Fetch current admin settings to get the latest logo
    fetch('/api/admin-settings')
        .then(response => response.json())
        .then(settings => {
            const logoUrl = `/static/${settings.logo_filename}?t=${Date.now()}`;
            updateLogoOverlay(logoUrl);
        })
        .catch(error => {
            console.error('Error fetching admin settings:', error);
            // Fallback to template value
            const logoUrl = '{{ url_for("static", filename=logo_filename) }}?t=' + Date.now();
            updateLogoOverlay(logoUrl);
        });
}

function updateLogoOverlay(logoUrl) {
    const logoOverlay = document.getElementById('logoOverlay');
    if (logoOverlay && logoUrl !== currentLogoUrl) {
        currentLogoUrl = logoUrl;
        logoOverlay.style.backgroundImage = `url('${logoUrl}')`;
        console.log('Logo overlay updated:', logoUrl);
    }
}

function calculateOptimalGrid(numEntries, settings) {
    if (settings && settings.grid_mode === 'manual') {
        return { 
            cols: settings.grid_cols || 12, 
            rows: settings.grid_rows || 10 
        };
    }
    
    if (numEntries === 0) return { cols: 1, rows: 1 };
    
    // Calculate grid dimensions based on number of entries
    // Try to maintain logo aspect ratio (4:3)
    const aspectRatio = mosaicWidth / mosaicHeight;
    
    // Find the best grid size for the number of entries
    let bestCols = 1, bestRows = 1;
    let minWaste = Infinity;
    
    for (let cols = 1; cols <= Math.ceil(Math.sqrt(numEntries * aspectRatio)) + 5; cols++) {
        const rows = Math.ceil(numEntries / cols);
        const totalCells = cols * rows;
        const waste = totalCells - numEntries;
        const currentRatio = cols / rows;
        const ratioError = Math.abs(currentRatio - aspectRatio);
        
        // Prefer grids closer to target aspect ratio with less waste
        const score = waste + (ratioError * 10);
        
        if (score < minWaste) {
            minWaste = score;
            bestCols = cols;
            bestRows = rows;
        }
    }
    
    return { cols: bestCols, rows: bestRows };
}

// Removed analyzeBackgroundImage - no longer needed for overlay approach

function setupMosaicGrid() {
    const wrapper = document.getElementById('photoMosaicWrapper');
    wrapper.style.position = 'relative';
    wrapper.style.width = '100%';
    wrapper.style.maxWidth = '1200px';
    wrapper.style.margin = '0 auto';
}

function setupDefaultGrid() {
    // Use fixed resolution even when background image fails
    const grid = calculateOptimalGrid(totalEntries, null);
    gridCols = grid.cols;
    gridRows = grid.rows;
    tileSize = Math.min(mosaicWidth / gridCols, mosaicHeight / gridRows);
    positionTiles();
}

// Removed getPixelData - no longer needed for overlay approach

function positionTiles(settings = null) {
    const tiles = document.querySelectorAll('.photo-tile');
    const grid = document.getElementById('photoMosaicGrid');
    
    if (!grid) return;
    
    // Calculate optimal grid based on settings and number of entries
    totalEntries = tiles.length;
    
    const optimalGrid = calculateOptimalGrid(totalEntries, settings);
    gridCols = optimalGrid.cols;
    gridRows = optimalGrid.rows;
    
    // Calculate tile size to fit fixed mosaic resolution
    tileSize = Math.min(mosaicWidth / gridCols, mosaicHeight / gridRows);
    
    // Adjust actual mosaic size to accommodate the grid perfectly
    const actualWidth = gridCols * tileSize;
    const actualHeight = gridRows * tileSize;
    
    grid.style.position = 'relative';
    grid.style.width = actualWidth + 'px';
    grid.style.height = actualHeight + 'px';
    grid.style.margin = '0 auto';
    grid.style.border = '2px solid rgba(255,255,255,0.3)';
    grid.style.imageRendering = 'pixelated'; // For crisp scaling when needed
    grid.style.imageRendering = '-moz-crisp-edges';
    grid.style.imageRendering = 'crisp-edges';
    
    // Create simple grid positions for tiles
    const positions = [];
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            const x = col * tileSize;
            const y = row * tileSize;
            
            positions.push({ 
                x, y, 
                row, col,
                index: positions.length
            });
        }
    }
    
    // Get or create persistent position assignments for entries
    const entryPositions = getEntryPositions(tiles.length, positions.length);
    
    // Position tiles using persistent entry positions
    tiles.forEach((tile, index) => {
        const entryId = tile.getAttribute('data-entry-id');
        const positionIndex = entryPositions[entryId] || entryPositions[index] || 0;
        
        if (positionIndex < positions.length) {
            const pos = positions[positionIndex];
            tile.style.position = 'absolute';
            tile.style.left = pos.x + 'px';
            tile.style.top = pos.y + 'px';
            tile.style.width = tileSize + 'px';
            tile.style.height = tileSize + 'px';
            
            // Simple tile styling without color analysis
            tile.style.transform = 'translateZ(0)'; // Force hardware acceleration
        }
    });
    
    // Fill remaining positions with empty tiles
    const totalPositions = gridCols * gridRows;
    if (totalPositions > tiles.length) {
        // Find unused positions
        const usedPositionIndices = new Set(Object.values(entryPositions).slice(0, tiles.length));
        
        for (let i = 0; i < positions.length; i++) {
            if (!usedPositionIndices.has(i)) {
                const pos = positions[i];
                const emptyTile = document.createElement('div');
                emptyTile.className = 'photo-tile empty-tile';
                emptyTile.style.position = 'absolute';
                emptyTile.style.left = pos.x + 'px';
                emptyTile.style.top = pos.y + 'px';
                emptyTile.style.width = tileSize + 'px';
                emptyTile.style.height = tileSize + 'px';
                
                // Simple empty tile without color analysis
                emptyTile.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                emptyTile.style.border = '1px solid rgba(255, 255, 255, 0.2)';
                
                grid.appendChild(emptyTile);
            }
        }
    }
}

function checkForNewEntries() {
    // Check entry count first to avoid unnecessary refreshes
    fetch('/api/entries')
        .then(response => response.json())
        .then(entries => {
            const currentCount = entries.length;
            
            // Only refresh if entry count changed or it's the first load
            if (currentCount !== lastEntryCount || lastEntryCount === 0) {
                lastEntryCount = currentCount;
                refreshMosaic(entries);
            }
        })
        .catch(error => {
            console.error('Error checking entries:', error);
        });
}

function refreshMosaic(entries = null) {
    // If entries not provided, fetch them along with settings
    if (entries === null) {
        Promise.all([
            fetch('/api/entries').then(response => response.json()),
            fetch('/api/admin-settings').then(response => response.json())
        ])
        .then(([entries, settings]) => {
            // Check if logo has changed
            const newLogoUrl = `/static/${settings.logo_filename}?t=${Date.now()}`;
            
            if (newLogoUrl !== currentLogoUrl) {
                // Logo changed, update overlay
                updateLogoOverlay(newLogoUrl);
            }
            
            updatePhotoMosaicGrid(entries, settings);
        })
        .catch(error => {
            console.error('Error refreshing mosaic:', error);
        });
    } else {
        // Use provided entries and fetch only settings
        fetch('/api/admin-settings')
            .then(response => response.json())
            .then(settings => {
                // Check if logo has changed
                const newLogoUrl = `/static/${settings.logo_filename}?t=${Date.now()}`;
                
                if (newLogoUrl !== currentLogoUrl) {
                    // Logo changed, update overlay
                    updateLogoOverlay(newLogoUrl);
                }
                
                updatePhotoMosaicGrid(entries, settings);
            })
            .catch(error => {
                console.error('Error fetching settings:', error);
                // Fallback to just entries without settings
                updatePhotoMosaicGrid(entries);
            });
    }
}

function getEntryPositions(entryCount, totalPositions) {
    // Get existing position assignments from localStorage
    let savedPositions = {};
    try {
        savedPositions = JSON.parse(localStorage.getItem('entryPositions') || '{}');
    } catch (e) {
        savedPositions = {};
    }
    
    // Create shuffled position pool if it doesn't exist
    let availablePositions = [];
    try {
        availablePositions = JSON.parse(localStorage.getItem('availablePositions') || '[]');
    } catch (e) {
        availablePositions = [];
    }
    
    // Initialize position pool if empty or wrong size
    if (availablePositions.length === 0 || availablePositions.length !== totalPositions) {
        availablePositions = Array.from({length: totalPositions}, (_, i) => i);
        // Shuffle the available positions
        for (let i = availablePositions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availablePositions[i], availablePositions[j]] = [availablePositions[j], availablePositions[i]];
        }
        localStorage.setItem('availablePositions', JSON.stringify(availablePositions));
    }
    
    // Assign positions to entries that don't have them
    const currentEntryIds = Array.from(document.querySelectorAll('.photo-tile')).map(tile => 
        tile.getAttribute('data-entry-id') || String(Array.from(tile.parentNode.children).indexOf(tile))
    );
    
    let nextPositionIndex = 0;
    currentEntryIds.forEach((entryId, index) => {
        if (!(entryId in savedPositions)) {
            // Find next available position
            while (nextPositionIndex < availablePositions.length && 
                   Object.values(savedPositions).includes(availablePositions[nextPositionIndex])) {
                nextPositionIndex++;
            }
            
            if (nextPositionIndex < availablePositions.length) {
                savedPositions[entryId] = availablePositions[nextPositionIndex];
                nextPositionIndex++;
            } else {
                // Fallback to index if we run out of positions
                savedPositions[entryId] = index % totalPositions;
            }
        }
    });
    
    // Save updated positions
    localStorage.setItem('entryPositions', JSON.stringify(savedPositions));
    
    return savedPositions;
}

function updatePhotoMosaicGrid(entries, settings = null) {
    const grid = document.getElementById('photoMosaicGrid');
    if (!grid) return;
    
    // Clear existing tiles (keep the grid structure)
    const existingTiles = grid.querySelectorAll('.photo-tile, .empty-tile');
    existingTiles.forEach(tile => tile.remove());
    
    if (entries.length === 0 && (!settings || settings.grid_mode !== 'manual')) {
        // Only reload if we're in auto mode and have no entries
        const emptyMessage = document.createElement('div');
        emptyMessage.className = 'empty-mosaic text-center py-5';
        emptyMessage.innerHTML = `
            <div class="display-1 mb-3 text-white-50">ðŸŽŠ</div>
            <h3 class="text-white">Building photo mosaic...</h3>
            <p class="text-white-50">Waiting for celebration tiles to appear</p>
            <p class="text-white-50 small">Updates automatically when new entries arrive</p>
        `;
        grid.appendChild(emptyMessage);
        return;
    }
    
    entries.forEach((entry, index) => {
        const tile = document.createElement('div');
        tile.className = 'photo-tile';
        // Use entry ID if available, otherwise fall back to index
        const entryId = entry.id || String(index);
        tile.setAttribute('data-entry-id', entryId);
        tile.setAttribute('data-bs-toggle', 'tooltip');
        tile.setAttribute('data-bs-title', `${escapeHtml(entry.name)}: ${escapeHtml(entry.message)}`);
        
        const name = entry.name.length > 15 ? entry.name.substring(0, 15) + '...' : entry.name;
        const message = entry.message.length > 35 ? entry.message.substring(0, 35) + '...' : entry.message;
        
        tile.innerHTML = `
            <div class="tile-bg-symbol">
                <img src="/static/symbols/${entry.symbol}" alt="Symbol" class="symbol-image">
            </div>
            <div class="tile-content">
                <div class="tile-name">${escapeHtml(name)}</div>
                <div class="tile-message">${escapeHtml(message)}</div>
            </div>
        `;
        
        grid.appendChild(tile);
    });
    
    // Reposition tiles after update
    setTimeout(() => {
        positionTiles(settings);
        initializeTooltips();
    }, 100);
    
    // Update counter
    const badge = document.querySelector('.badge.bg-info');
    if (badge) {
        const totalTiles = settings && settings.grid_mode === 'manual' 
            ? (settings.grid_rows || 10) * (settings.grid_cols || 12)
            : entries.length;
        badge.textContent = `${entries.length}/${totalTiles} tiles`;
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Handle window resize
window.addEventListener('resize', function() {
    setTimeout(() => {
        if (backgroundImage && backgroundImage.complete) {
            analyzeBackgroundImage();
            positionTiles();
        }
    }, 250);
});

// Clean up on page unload
window.addEventListener('beforeunload', () => {
    if (refreshInterval) {
        clearInterval(refreshInterval);
    }
});
</script>
{% endblock %}
