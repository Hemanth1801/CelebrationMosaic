{% extends "base.html" %}

{% block title %}Photo Mosaic - Celebration Display{% endblock %}

{% block content %}
<div class="photo-mosaic-container">
    <div class="container-fluid py-3">
        <div class="text-center mb-3">
            <h1 class="display-5 text-white mb-2">ðŸŽ‰ Photo Mosaic</h1>
            <p class="text-white-50">Small celebration tiles recreating the big picture</p>
            <div class="mb-3">
                <button class="btn btn-outline-light btn-sm" onclick="refreshMosaic()">ðŸ”„ Refresh Now</button>
                <span class="badge bg-success ms-2">Auto-refreshing every 10 seconds</span>
                <span class="badge bg-info ms-1">{{ entries|length }} tiles</span>
            </div>
        </div>

        <div class="photo-mosaic-wrapper" id="photoMosaicWrapper">
            <canvas id="analysisCanvas" style="display: none;"></canvas>
            <div id="photoMosaicGrid" class="photo-mosaic-grid">
                {% if entries %}
                    {% for entry in entries %}
                    <div class="photo-tile" data-entry-id="{{ loop.index }}" 
                         data-bs-toggle="tooltip" data-bs-title="{{ entry.name }}: {{ entry.message }}">
                        <div class="tile-symbol">{{ entry.symbol }}</div>
                        <div class="tile-name">{{ entry.name[:8] }}{% if entry.name|length > 8 %}...{% endif %}</div>
                        <div class="tile-message">{{ entry.message[:20] }}{% if entry.message|length > 20 %}...{% endif %}</div>
                    </div>
                    {% endfor %}
                {% else %}
                <div class="empty-mosaic text-center py-5">
                    <div class="display-1 mb-3 text-white-50">ðŸŽŠ</div>
                    <h3 class="text-white">Building photo mosaic...</h3>
                    <p class="text-white-50">Waiting for celebration tiles to appear</p>
                    <p class="text-white-50 small">Updates automatically when new entries arrive</p>
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<script>
// Photo Mosaic Variables
let backgroundImage = null;
let backgroundImageData = null;
let tileSize = 20;
let mosaicWidth = 800;  // Fixed logo resolution width
let mosaicHeight = 600; // Fixed logo resolution height
let gridCols = 0;
let gridRows = 0;
let refreshInterval;
let totalEntries = 0;
let lastEntryCount = 0;

// Initialize photo mosaic
document.addEventListener('DOMContentLoaded', function() {
    initializePhotoMosaic();
    initializeTooltips();
});

function initializeTooltips() {
    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
    [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));
}

function initializePhotoMosaic() {
    loadCurrentLogo();
    setupMosaicGrid();
    
    // Check for new entries every 3 seconds (but only refresh if count changed)
    refreshInterval = setInterval(checkForNewEntries, 3000);
}

function loadCurrentLogo() {
    // Fetch current admin settings to get the latest logo
    fetch('/api/admin-settings')
        .then(response => response.json())
        .then(settings => {
            const logoUrl = `/static/${settings.logo_filename}?t=${Date.now()}`;
            loadBackgroundImage(logoUrl);
        })
        .catch(error => {
            console.error('Error fetching admin settings:', error);
            // Fallback to template value
            const logoUrl = '{{ url_for("static", filename=logo_filename) }}?t=' + Date.now();
            loadBackgroundImage(logoUrl);
        });
}

function loadBackgroundImage(url) {
    backgroundImage = new Image();
    backgroundImage.crossOrigin = 'anonymous';
    backgroundImage.onload = function() {
        analyzeBackgroundImage();
        positionTiles();
    };
    backgroundImage.onerror = function() {
        console.log('Could not load background image, using default positioning');
        setupDefaultGrid();
    };
    backgroundImage.src = url;
}

function calculateOptimalGrid(numEntries, settings) {
    if (settings && settings.grid_mode === 'manual') {
        return { 
            cols: settings.grid_cols || 12, 
            rows: settings.grid_rows || 10 
        };
    }
    
    if (numEntries === 0) return { cols: 1, rows: 1 };
    
    // Calculate grid dimensions based on number of entries
    // Try to maintain logo aspect ratio (4:3)
    const aspectRatio = mosaicWidth / mosaicHeight;
    
    // Find the best grid size for the number of entries
    let bestCols = 1, bestRows = 1;
    let minWaste = Infinity;
    
    for (let cols = 1; cols <= Math.ceil(Math.sqrt(numEntries * aspectRatio)) + 5; cols++) {
        const rows = Math.ceil(numEntries / cols);
        const totalCells = cols * rows;
        const waste = totalCells - numEntries;
        const currentRatio = cols / rows;
        const ratioError = Math.abs(currentRatio - aspectRatio);
        
        // Prefer grids closer to target aspect ratio with less waste
        const score = waste + (ratioError * 10);
        
        if (score < minWaste) {
            minWaste = score;
            bestCols = cols;
            bestRows = rows;
        }
    }
    
    return { cols: bestCols, rows: bestRows };
}

function analyzeBackgroundImage() {
    const canvas = document.getElementById('analysisCanvas');
    const ctx = canvas.getContext('2d');
    
    // Use fixed resolution for consistent quality
    canvas.width = mosaicWidth;
    canvas.height = mosaicHeight;
    
    // Enable high-quality image rendering
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    
    // Draw background image at fixed resolution
    ctx.drawImage(backgroundImage, 0, 0, mosaicWidth, mosaicHeight);
    
    // Get image data for pixel analysis
    backgroundImageData = ctx.getImageData(0, 0, mosaicWidth, mosaicHeight);
}

function setupMosaicGrid() {
    const wrapper = document.getElementById('photoMosaicWrapper');
    wrapper.style.position = 'relative';
    wrapper.style.width = '100%';
    wrapper.style.maxWidth = '1200px';
    wrapper.style.margin = '0 auto';
}

function setupDefaultGrid() {
    // Use fixed resolution even when background image fails
    const grid = calculateOptimalGrid(totalEntries, null);
    gridCols = grid.cols;
    gridRows = grid.rows;
    tileSize = Math.min(mosaicWidth / gridCols, mosaicHeight / gridRows);
    positionTiles();
}

function getPixelData(x, y) {
    if (!backgroundImageData) return { r: 128, g: 128, b: 128, brightness: 128 };
    
    const index = (y * backgroundImageData.width + x) * 4;
    const r = backgroundImageData.data[index];
    const g = backgroundImageData.data[index + 1];
    const b = backgroundImageData.data[index + 2];
    
    // Calculate brightness using standard formula
    const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
    
    return { r, g, b, brightness };
}

function positionTiles(settings = null) {
    const tiles = document.querySelectorAll('.photo-tile');
    const grid = document.getElementById('photoMosaicGrid');
    
    if (!grid) return;
    
    // Calculate optimal grid based on settings and number of entries
    totalEntries = tiles.length;
    
    const optimalGrid = calculateOptimalGrid(totalEntries, settings);
    gridCols = optimalGrid.cols;
    gridRows = optimalGrid.rows;
    
    // Calculate tile size to fit fixed mosaic resolution
    tileSize = Math.min(mosaicWidth / gridCols, mosaicHeight / gridRows);
    
    // Adjust actual mosaic size to accommodate the grid perfectly
    const actualWidth = gridCols * tileSize;
    const actualHeight = gridRows * tileSize;
    
    grid.style.position = 'relative';
    grid.style.width = actualWidth + 'px';
    grid.style.height = actualHeight + 'px';
    grid.style.margin = '0 auto';
    grid.style.border = '2px solid rgba(255,255,255,0.3)';
    grid.style.imageRendering = 'pixelated'; // For crisp scaling when needed
    grid.style.imageRendering = '-moz-crisp-edges';
    grid.style.imageRendering = 'crisp-edges';
    
    // Create grid positions that match the background image
    const positions = [];
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            
            const x = col * tileSize;
            const y = row * tileSize;
            
            // Map position to original logo resolution for color sampling
            const logoX = (col / gridCols) * mosaicWidth;
            const logoY = (row / gridRows) * mosaicHeight;
            const pixelData = getPixelData(logoX, logoY);
            
            positions.push({ 
                x, y, 
                color: pixelData,
                row, col,
                index: positions.length
            });
        }
    }
    
    // Get or create persistent position assignments for entries
    const entryPositions = getEntryPositions(tiles.length, positions.length);
    
    // Position tiles using persistent entry positions
    tiles.forEach((tile, index) => {
        const entryId = tile.getAttribute('data-entry-id');
        const positionIndex = entryPositions[entryId] || entryPositions[index] || 0;
        
        if (positionIndex < positions.length) {
            const pos = positions[positionIndex];
            tile.style.position = 'absolute';
            tile.style.left = pos.x + 'px';
            tile.style.top = pos.y + 'px';
            tile.style.width = tileSize + 'px';
            tile.style.height = tileSize + 'px';
            
            // Enable high-quality scaling
            tile.style.imageRendering = 'auto';
            tile.style.imageRendering = '-webkit-optimize-contrast';
            tile.style.transform = 'translateZ(0)'; // Force hardware acceleration
            
            // Apply color tinting to match background image
            const { r, g, b, brightness } = pos.color;
            
            // Create color overlay effect with better blending
            tile.style.backgroundColor = `rgba(${r}, ${g}, ${b}, 0.4)`;
            tile.style.borderColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
            tile.style.mixBlendMode = 'multiply';
            
            // Adjust text color for contrast
            if (brightness < 128) {
                tile.style.color = '#fff';
                tile.style.textShadow = '1px 1px 2px rgba(0,0,0,0.9)';
            } else {
                tile.style.color = '#000';
                tile.style.textShadow = '1px 1px 2px rgba(255,255,255,0.9)';
            }
        }
    });
    
    // Fill remaining positions with empty tiles
    const totalPositions = gridCols * gridRows;
    if (totalPositions > tiles.length) {
        // Find unused positions
        const usedPositionIndices = new Set(Object.values(entryPositions).slice(0, tiles.length));
        
        for (let i = 0; i < positions.length; i++) {
            if (!usedPositionIndices.has(i)) {
                const pos = positions[i];
                const emptyTile = document.createElement('div');
                emptyTile.className = 'photo-tile empty-tile';
                emptyTile.style.position = 'absolute';
                emptyTile.style.left = pos.x + 'px';
                emptyTile.style.top = pos.y + 'px';
                emptyTile.style.width = tileSize + 'px';
                emptyTile.style.height = tileSize + 'px';
                
                const { r, g, b } = pos.color;
                emptyTile.style.backgroundColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
                emptyTile.style.border = `1px solid rgba(${r}, ${g}, ${b}, 0.8)`;
                emptyTile.style.mixBlendMode = 'multiply';
                
                grid.appendChild(emptyTile);
            }
        }
    }
}

function checkForNewEntries() {
    // Check entry count first to avoid unnecessary refreshes
    fetch('/api/entries')
        .then(response => response.json())
        .then(entries => {
            const currentCount = entries.length;
            
            // Only refresh if entry count changed or it's the first load
            if (currentCount !== lastEntryCount || lastEntryCount === 0) {
                lastEntryCount = currentCount;
                refreshMosaic(entries);
            }
        })
        .catch(error => {
            console.error('Error checking entries:', error);
        });
}

function refreshMosaic(entries = null) {
    // If entries not provided, fetch them along with settings
    if (entries === null) {
        Promise.all([
            fetch('/api/entries').then(response => response.json()),
            fetch('/api/admin-settings').then(response => response.json())
        ])
        .then(([entries, settings]) => {
            // Check if logo has changed
            const currentLogoUrl = backgroundImage ? backgroundImage.src : '';
            const newLogoUrl = `/static/${settings.logo_filename}?t=${Date.now()}`;
            
            if (!currentLogoUrl.includes(settings.logo_filename)) {
                // Logo changed, reload it
                loadBackgroundImage(newLogoUrl);
            }
            
            updatePhotoMosaicGrid(entries, settings);
        })
        .catch(error => {
            console.error('Error refreshing mosaic:', error);
        });
    } else {
        // Use provided entries and fetch only settings
        fetch('/api/admin-settings')
            .then(response => response.json())
            .then(settings => {
                // Check if logo has changed
                const currentLogoUrl = backgroundImage ? backgroundImage.src : '';
                const newLogoUrl = `/static/${settings.logo_filename}?t=${Date.now()}`;
                
                if (!currentLogoUrl.includes(settings.logo_filename)) {
                    // Logo changed, reload it
                    loadBackgroundImage(newLogoUrl);
                }
                
                updatePhotoMosaicGrid(entries, settings);
            })
            .catch(error => {
                console.error('Error fetching settings:', error);
                // Fallback to just entries without settings
                updatePhotoMosaicGrid(entries);
            });
    }
}

function getEntryPositions(entryCount, totalPositions) {
    // Get existing position assignments from localStorage
    let savedPositions = {};
    try {
        savedPositions = JSON.parse(localStorage.getItem('entryPositions') || '{}');
    } catch (e) {
        savedPositions = {};
    }
    
    // Create shuffled position pool if it doesn't exist
    let availablePositions = [];
    try {
        availablePositions = JSON.parse(localStorage.getItem('availablePositions') || '[]');
    } catch (e) {
        availablePositions = [];
    }
    
    // Initialize position pool if empty or wrong size
    if (availablePositions.length === 0 || availablePositions.length !== totalPositions) {
        availablePositions = Array.from({length: totalPositions}, (_, i) => i);
        // Shuffle the available positions
        for (let i = availablePositions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availablePositions[i], availablePositions[j]] = [availablePositions[j], availablePositions[i]];
        }
        localStorage.setItem('availablePositions', JSON.stringify(availablePositions));
    }
    
    // Assign positions to entries that don't have them
    const currentEntryIds = Array.from(document.querySelectorAll('.photo-tile')).map(tile => 
        tile.getAttribute('data-entry-id') || String(Array.from(tile.parentNode.children).indexOf(tile))
    );
    
    let nextPositionIndex = 0;
    currentEntryIds.forEach((entryId, index) => {
        if (!(entryId in savedPositions)) {
            // Find next available position
            while (nextPositionIndex < availablePositions.length && 
                   Object.values(savedPositions).includes(availablePositions[nextPositionIndex])) {
                nextPositionIndex++;
            }
            
            if (nextPositionIndex < availablePositions.length) {
                savedPositions[entryId] = availablePositions[nextPositionIndex];
                nextPositionIndex++;
            } else {
                // Fallback to index if we run out of positions
                savedPositions[entryId] = index % totalPositions;
            }
        }
    });
    
    // Save updated positions
    localStorage.setItem('entryPositions', JSON.stringify(savedPositions));
    
    return savedPositions;
}

function updatePhotoMosaicGrid(entries, settings = null) {
    const grid = document.getElementById('photoMosaicGrid');
    if (!grid) return;
    
    // Clear existing tiles (keep the grid structure)
    const existingTiles = grid.querySelectorAll('.photo-tile, .empty-tile');
    existingTiles.forEach(tile => tile.remove());
    
    if (entries.length === 0 && (!settings || settings.grid_mode !== 'manual')) {
        // Only reload if we're in auto mode and have no entries
        const emptyMessage = document.createElement('div');
        emptyMessage.className = 'empty-mosaic text-center py-5';
        emptyMessage.innerHTML = `
            <div class="display-1 mb-3 text-white-50">ðŸŽŠ</div>
            <h3 class="text-white">Building photo mosaic...</h3>
            <p class="text-white-50">Waiting for celebration tiles to appear</p>
            <p class="text-white-50 small">Updates automatically when new entries arrive</p>
        `;
        grid.appendChild(emptyMessage);
        return;
    }
    
    entries.forEach((entry, index) => {
        const tile = document.createElement('div');
        tile.className = 'photo-tile';
        // Use entry ID if available, otherwise fall back to index
        const entryId = entry.id || String(index);
        tile.setAttribute('data-entry-id', entryId);
        tile.setAttribute('data-bs-toggle', 'tooltip');
        tile.setAttribute('data-bs-title', `${escapeHtml(entry.name)}: ${escapeHtml(entry.message)}`);
        
        const name = entry.name.length > 6 ? entry.name.substring(0, 6) + '...' : entry.name;
        const message = entry.message.length > 15 ? entry.message.substring(0, 15) + '...' : entry.message;
        
        tile.innerHTML = `
            <div class="tile-symbol">${entry.symbol}</div>
            <div class="tile-name">${escapeHtml(name)}</div>
            <div class="tile-message">${escapeHtml(message)}</div>
        `;
        
        grid.appendChild(tile);
    });
    
    // Reposition tiles after update
    setTimeout(() => {
        positionTiles(settings);
        initializeTooltips();
    }, 100);
    
    // Update counter
    const badge = document.querySelector('.badge.bg-info');
    if (badge) {
        const totalTiles = settings && settings.grid_mode === 'manual' 
            ? (settings.grid_rows || 10) * (settings.grid_cols || 12)
            : entries.length;
        badge.textContent = `${entries.length}/${totalTiles} tiles`;
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Handle window resize
window.addEventListener('resize', function() {
    setTimeout(() => {
        if (backgroundImage && backgroundImage.complete) {
            analyzeBackgroundImage();
            positionTiles();
        }
    }, 250);
});

// Clean up on page unload
window.addEventListener('beforeunload', () => {
    if (refreshInterval) {
        clearInterval(refreshInterval);
    }
});
</script>
{% endblock %}
