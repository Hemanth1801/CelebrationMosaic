{% extends "base.html" %}

{% block title %}Pho// Photo Mosaic Variables
let tileSize = 50; // Original tile size
let mosaicWidth = 800;  // Initial mosaic width
let mosaicHeight = 600; // Initial mosaic height
let gridCols = 0;
let gridRows = 0;
let refreshInterval;
let totalEntries = 0;
let lastEntryCount = 0;
let currentLogoUrl = '';

// Function to get logo dimensions and set mosaic size
async function setMosaicDimensions(logoUrl) {
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = function() {
            const logoAspectRatio = this.width / this.height;
            // Keep a fixed width of 800px and calculate height based on aspect ratio
            mosaicWidth = 800;
            mosaicHeight = Math.round(mosaicWidth / logoAspectRatio);
            resolve();
        };
        img.onerror = function() {
            // If logo fails to load, keep default dimensions
            console.warn('Failed to load logo, using default dimensions');
            resolve();
        };
        img.src = logoUrl;
    });
}- Celebration Display{% endblock %}

{% block content %}
<div class="photo-mosaic-container" style="height: 100%; width: 100%; margin: 0; padding: 0;">
    <div class="container-fluid p-0" style="height: 100%; width: 100%;">
        <div class="photo-mosaic-wrapper" id="photoMosaicWrapper" style="height: 100%; width: 100%; margin: 0; padding: 0;">
            <div id="photoMosaicGrid" class="photo-mosaic-grid" style="height: 100%; width: 100%; margin: 0; padding: 0;">
                {% if entries %}
                    {% for entry in entries %}
                    <div class="photo-tile" data-entry-id="{{ entry.id }}" data-position="{{ entry.position }}"
                         data-bs-toggle="tooltip" data-bs-title="{{ entry.name }}: {{ entry.message }}">
                        <div class="tile-bg-symbol">
                            <img src="{{ url_for('static', filename='symbols/' + entry.symbol) }}" 
                                 alt="Symbol" class="symbol-image">
                        </div>
                        <div class="tile-content">
                            <div class="tile-name">{{ entry.name[:15] }}{% if entry.name|length > 15 %}...{% endif %}</div>
                            <div class="tile-message">{{ entry.message[:35] }}{% if entry.message|length > 35 %}...{% endif %}</div>
                        </div>
                    </div>
                    {% endfor %}
                {% else %}
                <div class="empty-mosaic text-center py-5">
                    <div class="display-1 mb-3 text-white-50">ðŸŽŠ</div>
                    <h3 class="text-white">Building photo mosaic...</h3>
                    <p class="text-white-50">Waiting for celebration tiles to appear</p>
                    <p class="text-white-50 small">Updates automatically when new entries arrive</p>
                </div>
                {% endif %}
            </div>
            <div id="logoOverlay" class="logo-overlay"></div>
        </div>
    </div>
</div>

<script>
// Photo Mosaic Variables
let tileSize = 50; // Original tile size
let mosaicWidth = window.innerWidth;  // Use full viewport width
let mosaicHeight = window.innerHeight; // Use full viewport height
let gridCols = 0;
let gridRows = 0;
let refreshInterval;
let totalEntries = 0;
let lastEntryCount = 0;
let currentLogoUrl = '';

// Initialize photo mosaic
document.addEventListener('DOMContentLoaded', function() {
    initializePhotoMosaic();
    initializeTooltips();
});

function initializeTooltips() {
    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
    [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));
}

function initializePhotoMosaic() {
    setupMosaicGrid();
    loadLogoOverlay();
    
    // Load initial entries immediately
    checkForNewEntries();
    
    // Check for new entries every 3 seconds (but only refresh if count changed)
    refreshInterval = setInterval(checkForNewEntries, 3000);
}

async function loadLogoOverlay() {
    try {
        // Fetch current admin settings to get the latest logo
        const response = await fetch('/api/admin-settings');
        const settings = await response.json();
        const logoUrl = `/static/${settings.logo_filename}?t=${Date.now()}`;
        await setMosaicDimensions(logoUrl);
        updateLogoOverlay(logoUrl);
        setupDefaultGrid(); // Recalculate grid with new dimensions
    } catch (error) {
        console.error('Error fetching admin settings:', error);
        // Fallback to template value
        const logoUrl = '{{ url_for("static", filename=logo_filename) }}?t=' + Date.now();
        await setMosaicDimensions(logoUrl);
        updateLogoOverlay(logoUrl);
        setupDefaultGrid(); // Recalculate grid with new dimensions
    }
}

function updateLogoOverlay(logoUrl) {
    const logoOverlay = document.getElementById('logoOverlay');
    if (logoOverlay && logoUrl !== currentLogoUrl) {
        currentLogoUrl = logoUrl;
        logoOverlay.style.backgroundImage = `url('${logoUrl}')`;
    }
}

async function calculateOptimalGrid(numEntries, settings) {
    return new Promise((resolve) => {
        // Use requestAnimationFrame for smooth non-blocking calculation
        requestAnimationFrame(() => {
            if (settings && settings.grid_mode === 'manual') {
                resolve({ 
                    cols: settings.grid_cols || 12, 
                    rows: settings.grid_rows || 10 
                });
                return;
            }
            
            if (numEntries === 0) {
                resolve({ cols: 1, rows: 1 });
                return;
            }
            
            // Calculate grid dimensions based on number of entries
            // Try to maintain logo aspect ratio (4:3)
            const aspectRatio = mosaicWidth / mosaicHeight;
            
            // Find the best grid size for the number of entries
            let bestCols = 1, bestRows = 1;
            let minWaste = Infinity;
            
            const maxCols = Math.ceil(Math.sqrt(numEntries * aspectRatio)) + 5;
            
            // Break calculation into chunks to avoid blocking
            let currentCol = 1;
            const calculateChunk = () => {
                const endCol = Math.min(currentCol + 5, maxCols + 1);
                
                for (let cols = currentCol; cols < endCol; cols++) {
                    const rows = Math.ceil(numEntries / cols);
                    const totalCells = cols * rows;
                    const waste = totalCells - numEntries;
                    const currentRatio = cols / rows;
                    const ratioError = Math.abs(currentRatio - aspectRatio);
                    
                    // Prefer grids closer to target aspect ratio with less waste
                    const score = waste + (ratioError * 10);
                    
                    if (score < minWaste) {
                        minWaste = score;
                        bestCols = cols;
                        bestRows = rows;
                    }
                }
                
                currentCol = endCol;
                if (currentCol <= maxCols) {
                    requestAnimationFrame(calculateChunk);
                } else {
                    resolve({ cols: bestCols, rows: bestRows });
                }
            };
            
            calculateChunk();
        });
    });
}


function setupMosaicGrid() {
    const wrapper = document.getElementById('photoMosaicWrapper');
    const grid = document.getElementById('photoMosaicGrid');
    
    // Calculate available space accounting for header
    const headerHeight = 80; // Height of fixed header
    const availableHeight = window.innerHeight - headerHeight;
    
    wrapper.style.position = 'relative';
    wrapper.style.width = '100%';
    wrapper.style.height = `${availableHeight}px`;
    wrapper.style.margin = '0';
    wrapper.style.padding = '0';
    wrapper.style.overflow = 'hidden';
    
    // Set grid dimensions
    if (grid) {
        grid.style.width = '100%';
        grid.style.height = '100%';
        grid.style.position = 'relative';
        grid.style.overflow = 'hidden';
        
        // Update mosaic dimensions
        mosaicWidth = wrapper.clientWidth;
        mosaicHeight = wrapper.clientHeight;
    }
}

async function setupDefaultGrid() {
    // Use fixed resolution even when background image fails
    try {
        const grid = await calculateOptimalGrid(totalEntries, null);
        gridCols = grid.cols;
        gridRows = grid.rows;
        tileSize = Math.min(mosaicWidth / gridCols, mosaicHeight / gridRows);
        await positionTiles();
    } catch (error) {
        console.error('Error setting up default grid:', error);
    }
}


async function positionTiles(settings = null) {
    const tiles = document.querySelectorAll('.photo-tile');
    const grid = document.getElementById('photoMosaicGrid');
    
    if (!grid) return;
    
    // Calculate optimal grid based on settings and number of entries
    totalEntries = tiles.length;
    
    // Run grid calculation asynchronously
    const optimalGrid = await calculateOptimalGrid(totalEntries, settings);
    gridCols = optimalGrid.cols;
    gridRows = optimalGrid.rows;
    
    // Calculate tile size to fit fixed mosaic resolution
    tileSize = Math.min(mosaicWidth / gridCols, mosaicHeight / gridRows);
    
    // Adjust actual mosaic size to accommodate the grid perfectly
    const actualWidth = gridCols * tileSize;
    const actualHeight = gridRows * tileSize;
    
    
    // Apply grid styles immediately
    requestAnimationFrame(() => {
        grid.style.position = 'relative';
        grid.style.width = actualWidth + 'px';
        grid.style.height = actualHeight + 'px';
        grid.style.margin = '0 auto';
        grid.style.border = '2px solid rgba(255,255,255,0.3)';
        grid.style.imageRendering = 'pixelated';
        grid.style.imageRendering = '-moz-crisp-edges';
        grid.style.imageRendering = 'crisp-edges';
    });
    
    // Create positions and get entry positions in parallel
    const [positions, entryPositions] = await Promise.all([
        createGridPositions(gridRows, gridCols, tileSize),
        getEntryPositions(tiles.length, gridRows * gridCols)
    ]);
    
    // Position tiles in batches for smooth animation
    await positionTilesInBatches(tiles, positions, entryPositions);
    
    // Fill remaining positions with empty tiles
    await fillEmptyPositions(grid, positions, entryPositions, tiles.length);
}

async function createGridPositions(gridRows, gridCols, tileSize) {
    return new Promise((resolve) => {
        requestAnimationFrame(() => {
            const positions = [];
            for (let row = 0; row < gridRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    const x = col * tileSize;
                    const y = row * tileSize;
                    
                    positions.push({ 
                        x, y, 
                        row, col,
                        index: positions.length
                    });
                }
            }
            resolve(positions);
        });
    });
}

function checkTileOverlap(tile1Rect, tile2Rect) {
    return !(
        tile1Rect.right <= tile2Rect.left ||
        tile1Rect.left >= tile2Rect.right ||
        tile1Rect.bottom <= tile2Rect.top ||
        tile1Rect.top >= tile2Rect.bottom
    );
}

async function positionTilesInBatches(tiles, positions, entryPositions) {
    const batchSize = 5;
    const tilesArray = Array.from(tiles);
    
    for (let i = 0; i < tilesArray.length; i += batchSize) {
        await new Promise((resolve) => {
            requestAnimationFrame(() => {
                const batch = tilesArray.slice(i, i + batchSize);
                
                batch.forEach((tile) => {
                    const entryId = tile.getAttribute('data-entry-id');
                    const storedPosition = parseInt(tile.getAttribute('data-position'));
                    
                    if (!isNaN(storedPosition) && storedPosition >= 0 && storedPosition < positions.length) {
                        // Calculate row and column from position
                        const row = Math.floor(storedPosition / gridCols);
                        const col = storedPosition % gridCols;
                        
                        // Calculate x and y coordinates
                        const x = col * tileSize;
                        const y = row * tileSize;
                        
                        // Position the tile
                        tile.style.position = 'absolute';
                        tile.style.left = x + 'px';
                        tile.style.top = y + 'px';
                        tile.style.width = tileSize + 'px';
                        tile.style.height = tileSize + 'px';
                        
                        console.log(`Tile ${entryId} positioned at (${x}, ${y}), grid position: ${storedPosition}`);
                    } else {
                        console.warn(`Invalid position for tile ${entryId}: ${storedPosition}`);
                    }
                });
                
                resolve();
            });
        });
    }
}

async function fillEmptyPositions(grid, positions, entryPositions, tileCount) {
    const totalPositions = positions.length;
    if (totalPositions <= tileCount) return;
    
    return new Promise((resolve) => {
        requestAnimationFrame(() => {
            // Find unused positions
            const usedPositionIndices = new Set(Object.values(entryPositions).slice(0, tileCount));
            
            for (let i = 0; i < positions.length; i++) {
                if (!usedPositionIndices.has(i)) {
                    const pos = positions[i];
                    const emptyTile = document.createElement('div');
                    emptyTile.className = 'photo-tile empty-tile';
                    emptyTile.style.position = 'absolute';
                    emptyTile.style.left = pos.x + 'px';
                    emptyTile.style.top = pos.y + 'px';
                    emptyTile.style.width = tileSize + 'px';
                    emptyTile.style.height = tileSize + 'px';
                    
                    // Simple empty tile without color analysis
                    emptyTile.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                    emptyTile.style.border = '1px solid rgba(255, 255, 255, 0.2)';
                    
                    grid.appendChild(emptyTile);
                }
            }
            
            resolve();
        });
    });
}

function checkForNewEntries() {
    // Check entry count first to avoid unnecessary refreshes
    fetch('/api/entries')
        .then(response => response.json())
        .then(entries => {
            const currentCount = entries.length;
            
            // Only refresh if entry count changed or it's the first load
            if (currentCount !== lastEntryCount || lastEntryCount === 0) {
                const wasNewEntry = lastEntryCount > 0 && currentCount > lastEntryCount;
                lastEntryCount = currentCount;
                refreshMosaic(entries, wasNewEntry);
                
                // Trigger celebration if there's a new entry
                if (wasNewEntry) {
                    setTimeout(() => {
                        startCelebration();
                    }, 1000); // Delay to allow grid to render first
                }
            }
        })
        .catch(error => {
            console.error('Error checking entries:', error);
        });
}

function refreshMosaic(entries = null, animateNew = false) {
    return new Promise((resolve) => {
        // If entries not provided, fetch them along with settings
        if (entries === null) {
            Promise.all([
                fetch('/api/entries').then(response => response.json()),
                fetch('/api/admin-settings').then(response => response.json())
            ])
            .then(([entries, settings]) => {
                // Check if logo has changed
                const newLogoUrl = `/static/${settings.logo_filename}?t=${Date.now()}`;
                
                if (newLogoUrl !== currentLogoUrl) {
                    // Logo changed, update overlay
                    updateLogoOverlay(newLogoUrl);
                }
                
                updatePhotoMosaicGrid(entries, settings, animateNew);
                resolve();
            })
            .catch(error => {
                console.error('Error refreshing mosaic:', error);
                resolve();
            });
        } else {
            // Use provided entries and fetch only settings
            fetch('/api/admin-settings')
                .then(response => response.json())
                .then(settings => {
                    // Check if logo has changed
                    const newLogoUrl = `/static/${settings.logo_filename}?t=${Date.now()}`;
                    
                    if (newLogoUrl !== currentLogoUrl) {
                        // Logo changed, update overlay
                        updateLogoOverlay(newLogoUrl);
                    }
                    
                    updatePhotoMosaicGrid(entries, settings, animateNew);
                    resolve();
                })
                .catch(error => {
                    console.error('Error fetching settings:', error);
                    // Fallback to just entries without settings
                    updatePhotoMosaicGrid(entries, null, animateNew);
                    resolve();
                });
        }
    });
}

async function getEntryPositions(entryCount, totalPositions) {
    return new Promise((resolve) => {
        requestAnimationFrame(() => {
            const entryPositions = {};
            // Get all current tiles
            const currentTiles = Array.from(document.querySelectorAll('.photo-tile'));
            
            // Create a positions map from the data-position attributes
            const positions = {};
            currentTiles.forEach(tile => {
                const entryId = tile.getAttribute('data-entry-id');
                const position = parseInt(tile.getAttribute('data-position'));
                if (!isNaN(position) && position >= 0 && position < totalPositions) {
                    positions[entryId] = position;
                }
            });
            
            resolve(positions);
        });
    });
}

function updatePhotoMosaicGrid(entries, settings = null, animateNewest = false) {
    const grid = document.getElementById('photoMosaicGrid');
    if (!grid) return;
    
    // Store previous entry count to detect new entries
    const previousTiles = grid.querySelectorAll('.photo-tile');
    const hadEntries = previousTiles.length > 0;
    const isNewEntry = hadEntries && entries.length > previousTiles.length;
    
    // Clear existing tiles (keep the grid structure)
    const existingTiles = grid.querySelectorAll('.photo-tile, .empty-tile');
    existingTiles.forEach(tile => tile.remove());
    
    if (entries.length === 0 && (!settings || settings.grid_mode !== 'manual')) {
        // Only reload if we're in auto mode and have no entries
        const emptyMessage = document.createElement('div');
        emptyMessage.className = 'empty-mosaic text-center py-5';
        emptyMessage.innerHTML = `
            <div class="display-1 mb-3 text-white-50">ðŸŽŠ</div>
            <h3 class="text-white">Building photo mosaic...</h3>
            <p class="text-white-50">Waiting for celebration tiles to appear</p>
            <p class="text-white-50 small">Updates automatically when new entries arrive</p>
        `;
        grid.appendChild(emptyMessage);
        return;
    }
    
    entries.forEach((entry, index) => {
        const tile = document.createElement('div');
        tile.className = 'photo-tile';
        const entryId = entry.id || String(index);
        tile.setAttribute('data-entry-id', entryId);
        tile.setAttribute('data-position', entry.position);
        tile.setAttribute('data-bs-toggle', 'tooltip');
        tile.setAttribute('data-bs-title', `${escapeHtml(entry.name)}: ${escapeHtml(entry.message)}`);
        
        const name = entry.name.length > 15 ? entry.name.substring(0, 15) + '...' : entry.name;
        const message = entry.message.length > 35 ? entry.message.substring(0, 35) + '...' : entry.message;
        
        tile.innerHTML = `
            <div class="tile-bg-symbol">
                <img src="/static/symbols/${entry.symbol}" alt="Symbol" class="symbol-image">
            </div>
            <div class="tile-content">
                <div class="tile-name">${escapeHtml(name)}</div>
                <div class="tile-message">${escapeHtml(message)}</div>
            </div>
        `;
        
        grid.appendChild(tile);
    });
    
    // Reposition tiles after update using async positioning
    setTimeout(async () => {
        try {
            await positionTiles(settings);
            initializeTooltips();
        } catch (error) {
            console.error('Error positioning tiles:', error);
        }
    }, 50);
    
    // Update counter
    const badge = document.querySelector('.badge.bg-info');
    if (badge) {
        const totalTiles = settings && settings.grid_mode === 'manual' 
            ? (settings.grid_rows || 10) * (settings.grid_cols || 12)
            : entries.length;
        badge.textContent = `${entries.length}/${totalTiles} tiles`;
    }
}

function startCelebration() {
    // Fetch celebration animations from settings
    fetch('/api/admin-settings')
        .then(response => response.json())
        .then(settings => {
            const availableAnimations = settings?.celebration_animations || ['confetti'];
            console.log('Available animations:', availableAnimations);
            
            if (!availableAnimations || availableAnimations.length === 0) {
                console.warn('No celebration animations available, using confetti as fallback');
                playAnimation('confetti');
                return;
            }
            
            // Randomly select one of the enabled animations
            const effectType = availableAnimations[Math.floor(Math.random() * availableAnimations.length)];
            console.log('Selected animation:', effectType);
            
            // Create multiple effects if this is a milestone entry (every 10th entry)
            const entries = document.querySelectorAll('.photo-tile').length;
            const isMultipleOf10 = entries % 10 === 0;
            
            if (isMultipleOf10 && availableAnimations.length > 1) {
                // Show two random different animations for milestone entries
                const otherAnimations = availableAnimations.filter(a => a !== effectType);
                const secondEffect = otherAnimations[Math.floor(Math.random() * otherAnimations.length)];
                console.log('Milestone entry! Playing animations:', effectType, secondEffect);
                
                // Play both animations with a slight delay
                try {
                    playAnimation(effectType);
                    setTimeout(() => playAnimation(secondEffect), 500);
                } catch (error) {
                    console.error('Error playing milestone animations:', error);
                    createConfetti(); // Fallback to confetti
                }
            } else {
                // Play single animation
                try {
                    console.log('Playing single animation:', effectType);
                    playAnimation(effectType);
                } catch (error) {
                    console.error('Error playing animation:', error);
                    createConfetti(); // Fallback to confetti
                }
            }
            
            // Show popup with newest entry
            fetch('/api/entries')
                .then(response => response.json())
                .then(entries => {
                    if (entries.length > 0) {
                        const newestEntry = entries[entries.length - 1];
                        showCelebrationPopup(newestEntry);
                    }
                })
                .catch(error => {
                    console.error('Error getting newest entry:', error);
                });
        })
        .catch(error => {
            console.error('Error fetching celebration animation settings:', error);
            createConfetti(); // Default to confetti on error
        });
}

function playAnimation(effectType) {
    console.log('Playing animation:', effectType);
    try {
        switch(effectType) {
            case 'diwali':
                console.log('Creating Diwali crackers...');
                createDiwaliCrackers();
                break;
            case 'fireworks':
                console.log('Creating fireworks...');
                createFireworks();
                break;
            case 'sparkle-rain':
                console.log('Creating sparkle rain...');
                createSparkleRain();
                break;
            case 'flower-burst':
                console.log('Creating flower burst...');
                createFlowerBurst();
                break;
            case 'rangoli':
                console.log('Creating rangoli pattern...');
                createRangoliPattern();
                break;
            default:
                console.log('Using default confetti animation...');
                createConfetti();
                break;
        }
    } catch (error) {
        console.error('Error in playAnimation:', error);
        console.log('Falling back to confetti...');
        createConfetti();
    }
}

function createConfetti() {
    const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffa500', '#ff69b4'];
    
    for (let i = 0; i < 50; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.animationDelay = Math.random() * 3 + 's';
        confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
        
        document.body.appendChild(confetti);
        
        // Remove confetti after animation
        setTimeout(() => {
            if (confetti.parentNode) {
                confetti.remove();
            }
        }, 5000);
    }
}

function createDiwaliCrackers() {
    const crackerColors = ['#ffcc00', '#ff6600', '#ff9900', '#ffdd44', '#ff4400'];
    
    for (let i = 0; i < 15; i++) {
        const cracker = document.createElement('div');
        cracker.className = 'diwali-cracker';
        cracker.style.background = `radial-gradient(circle, ${crackerColors[Math.floor(Math.random() * crackerColors.length)]}, #ff3300)`;
        cracker.style.left = Math.random() * 100 + 'vw';
        cracker.style.top = Math.random() * 100 + 'vh';
        cracker.style.animationDelay = Math.random() * 2 + 's';
        
        document.body.appendChild(cracker);
        
        // Remove cracker after animation
        setTimeout(() => {
            if (cracker.parentNode) {
                cracker.remove();
            }
        }, 3500);
    }
}

function createFireworks() {
    const fireworkColors = ['#ff0040', '#00ff80', '#4080ff', '#ffff00', '#ff8000', '#8000ff'];
    
    for (let i = 0; i < 5; i++) {
        setTimeout(() => {
            const centerX = Math.random() * 80 + 10;
            const centerY = Math.random() * 60 + 20;
            const color = fireworkColors[Math.floor(Math.random() * fireworkColors.length)];
            
            for (let j = 0; j < 12; j++) {
                const spark = document.createElement('div');
                spark.className = 'firework';
                spark.style.backgroundColor = color;
                spark.style.boxShadow = `0 0 10px ${color}`;
                spark.style.left = centerX + '%';
                spark.style.top = centerY + '%';
                
                const angle = (j * 30) + Math.random() * 15;
                const distance = 50 + Math.random() * 100;
                const radians = (angle * Math.PI) / 180;
                const moveX = Math.cos(radians) * distance;
                const moveY = Math.sin(radians) * distance;
                
                spark.style.transform = `translate(${moveX}px, ${moveY}px)`;
                
                document.body.appendChild(spark);
                
                setTimeout(() => spark.remove(), 1500);
            }
        }, i * 500);
    }
}

function createSparkleRain() {
    const colors = ['#FFD700', '#FFA500', '#FF69B4', '#7B68EE'];
    
    for (let i = 0; i < 30; i++) {
        setTimeout(() => {
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            sparkle.style.left = Math.random() * 100 + 'vw';
            sparkle.style.setProperty('--x-offset', (Math.random() * 200 - 100) + 'px');
            sparkle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            
            document.body.appendChild(sparkle);
            
            setTimeout(() => sparkle.remove(), 3000);
        }, i * 100);
    }
}

function createFlowerBurst() {
    console.log('Starting flower burst animation...');
    const colors = [
        ['#ff6b6b', '#ffe66d'],
        ['#4ecdc4', '#ffe66d'],
        ['#ff8b94', '#ffd3b6']
    ];
    
    // Clean up any existing animations
    document.querySelectorAll('.flower').forEach(el => el.remove());
    
    for (let i = 0; i < 10; i++) {
        setTimeout(() => {
            const flower = document.createElement('div');
            flower.className = 'flower';
            flower.style.left = Math.random() * 90 + 5 + '%';
            flower.style.top = Math.random() * 90 + 5 + '%';
            
            const colorPair = colors[Math.floor(Math.random() * colors.length)];
            flower.style.background = `radial-gradient(circle, ${colorPair[0]}, ${colorPair[1]})`;
            
            document.body.appendChild(flower);
            console.log(`Created flower ${i + 1} at position:`, { left: flower.style.left, top: flower.style.top });
            
            setTimeout(() => {
                if (flower.parentNode) {
                    flower.remove();
                    console.log(`Removed flower ${i + 1}`);
                }
            }, 2000);
        }, i * 200);
    }
}

function createRangoliPattern() {
    console.log('Starting rangoli pattern animation...');
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    const patternCount = 8;
    
    // Clean up any existing animations
    document.querySelectorAll('.rangoli').forEach(el => el.remove());
    
    for (let i = 0; i < patternCount; i++) {
        const rangoli = document.createElement('div');
        rangoli.className = 'rangoli';
        
        const angle = (i * 360 / patternCount) * (Math.PI / 180);
        const distance = 150;
        const x = centerX + Math.cos(angle) * distance;
        const y = centerY + Math.sin(angle) * distance;
        
        rangoli.style.left = (x - 50) + 'px';
        rangoli.style.top = (y - 50) + 'px';
        
        document.body.appendChild(rangoli);
        console.log(`Created rangoli pattern ${i + 1} at position:`, { left: rangoli.style.left, top: rangoli.style.top });
        
        setTimeout(() => {
            if (rangoli.parentNode) {
                rangoli.remove();
                console.log(`Removed rangoli pattern ${i + 1}`);
            }
        }, 2000);
    }
}

function showCelebrationPopup(entry) {
    
    // Create overlay
    const overlay = document.createElement('div');
    overlay.className = 'celebration-overlay';
    
    // Create popup tile
    const popupTile = document.createElement('div');
    popupTile.className = 'photo-tile celebration-popup';
    
    const name = entry.name.length > 15 ? entry.name.substring(0, 15) + '...' : entry.name;
    const message = entry.message.length > 50 ? entry.message.substring(0, 50) + '...' : entry.message;
    
    popupTile.innerHTML = `
        <div class="tile-bg-symbol">
            <img src="/static/symbols/${entry.symbol}" alt="Symbol" class="symbol-image">
        </div>
        <div class="tile-content">
            <div class="tile-name">${escapeHtml(name)}</div>
            <div class="tile-message">${escapeHtml(message)}</div>
        </div>
    `;
    
    overlay.appendChild(popupTile);
    document.body.appendChild(overlay);
    
    
    // After popup animation, move to grid
    setTimeout(() => {
        movePopupToGrid(popupTile, overlay, entry);
    }, 2500);
}

function movePopupToGrid(popupTile, overlay, entry) {
    // First, remove any existing animations from tiles
    document.querySelectorAll('.newest-tile').forEach(tile => {
        tile.classList.remove('newest-tile');
        tile.removeAttribute('data-animation');
    });

    // Then refresh the mosaic
    refreshMosaic(null, false).then(() => {
        // Find the newest tile in the grid
        const gridTiles = document.querySelectorAll('.photo-tile:not(.celebration-popup)');
        if (gridTiles.length > 0) {
            const newestGridTile = gridTiles[gridTiles.length - 1];
            
            // Get target position
            const finalLeft = newestGridTile.style.left;
            const finalTop = newestGridTile.style.top;
            const finalWidth = newestGridTile.style.width;
            const finalHeight = newestGridTile.style.height;
            
            // Hide the grid tile temporarily
            newestGridTile.style.opacity = '0';
            
            // Set final position properties for animation
            popupTile.style.setProperty('--final-left', finalLeft);
            popupTile.style.setProperty('--final-top', finalTop);
            popupTile.style.setProperty('--final-width', finalWidth);
            popupTile.style.setProperty('--final-height', finalHeight);
            
            // Show the celebration popup
            popupTile.classList.add('celebration-popup');
            
            // After popup animation
            setTimeout(() => {
                // Remove overlay and popup
                overlay.remove();
                
                // Show the grid tile
                newestGridTile.style.opacity = '1';
                
                // Add auto hover effect
                newestGridTile.classList.add('auto-hover');
                console.log('Added hover effect');
                
                // Remove hover effect after 1.5 seconds
                setTimeout(() => {
                    newestGridTile.classList.remove('auto-hover');
                    console.log('Removed hover effect');
                }, 500);
            }, 500); // auto hover timing
        }
    });
}



function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Handle window resize
window.addEventListener('resize', function() {
    setTimeout(() => {
        positionTiles();
    }, 250);
});

// Clean up on page unload
window.addEventListener('beforeunload', () => {
    if (refreshInterval) {
        clearInterval(refreshInterval);
    }
});
</script>
{% endblock %}
